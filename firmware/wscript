#! /usr/bin/env python
# encoding: utf-8

'''
@author: Milos Subotic <milos.subotic.sm@gmail.com>
@license: MIT

'''

###############################################################################

import os
import sys

import crosswaf
from crosswaf import *
from common_waf import *

###############################################################################

def options(opt):
	#opt.load('gcc gxx')
	opt.load('c cxx')

	opt.add_option(
		'--compiler',
		choices = [
			'riscv',
			'pc',
		],
		help = 'Selection of compiler'
	)
	opt.add_option(
		'--cross-compile',
		dest = 'CROSS_COMPILE',
		default = '/opt/riscv32im/bin/riscv32-unknown-elf-',
		help = 'Cross-compiler'
	)

	opt.add_option(
		'--app',
		dest = 'app',
		default = None,
		help = 'App to be uploaded to MCU'
	)
	opt.add_option(
		'--port',
		dest = 'port',
		default = '0',
		help = 'Programmer port number or full file name i.e. dev file ' +
			'(2, /dev/ttyUSB2, COM2)'
	)

def configure(cfg):
	cfg.find_program(
		'makehex',
		var = 'MAKEHEX',
		exts = '.py',
		path_list = str(cfg.srcnode)
	)

	icp = cfg.srcnode.find_node('../software/max1000_riscv_loader/')
	pl = str(icp.find_node('build'))
	for p in ['max1000_riscv_loader']:
		cfg.find_program(
			p,
			var = p,
			path_list = pl
		)

	cfg.env['options.compiler'] = cfg.options.compiler
	if cfg.options.compiler == 'pc':
		cfg.env.ARCH = 'x86-64'
		cfg.load('gcc g++')
	elif cfg.options.compiler == 'riscv':
		cfg.env.ARCH = 'riscv'
		cfg.env.CROSS_COMPILE = cfg.options.CROSS_COMPILE
		cfg.load('bare_metal_gcc', tooldir = crosswaf.location)
		f = [
			'-g',
			'-Os',
		]
		cfg.env.CFLAGS += f
		cfg.env.CXXFLAGS += f
		cfg.env.ASFLAGS += f
		cfg.env.STLIB_MARKER += ',-T,../picorv32.lds,-Map,fw_playground.map'
	#cfg.env.append_value('CFLAGS', '-std=c99')
	#cfg.env.append_value('CXXFLAGS', '-std=c++11')


def build(bld):

	for code_file in glob_apps_srcs(bld):
		name = os.path.splitext(code_file)[0]
		source = [code_file]
		if bld.env.ARCH == 'riscv':
			source.append('init.S')
		bld.program(
			features = 'cxx',
			includes = '.',
			source = source,
			target = name + '.elf'
		)
		bld(
			rule = '"${OBJDUMP}" -S "${SRC}" > "${TGT[0]}"',
			source = name + '.elf',
			target = name + '.lst'
		)
		bld(
			rule = '"${OBJCOPY}" -O binary "${SRC}" "${TGT[0]}"',
			source = name + '.elf',
			target = name + '.bin'
		)
		#TODO Parse this .hex in loader, instead of .fake.hex
		bld(
			rule = '"${OBJCOPY}" -O ihex "${SRC}" "${TGT[0]}"',
			source = name + '.elf',
			target = name + '.hex'
		)
		bld(
			rule = '${MAKEHEX} "${SRC}" 3072 "${TGT[0]}"',
			source = name + '.bin',
			target = name + '.fake.hex'
		)


@after_cmd(build)
@build_context
def upload(ctx):
	if ctx.options.port:
		p = ctx.options.port
	else:
		p = '0'
	port = expand_port(p)
	if ctx.options.app:
		app = expand_app(ctx.options.app)
		hex = f'{app}.fake.hex'
		ctx.exec_command2('./serial_on')
		ctx.exec_command2(f'ls -ll {port}')
		ctx.exec_command2('sleep 1')
		ctx.exec_command2(f'ls -ll {port}')
		ctx.exec_command2(['echo', '${max1000_riscv_loader}'])
		ctx.exec_command2(['${max1000_riscv_loader}', port, f'build/{hex}'])
		ctx.exec_command2('./serial_off')

###############################################################################
